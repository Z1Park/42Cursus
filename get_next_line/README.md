- 개요

c언어의 read 함수와 static 변수에 대해 이해하고, 그를 통해 표준 입력 및 파일 디스크립터를 받아 파일이나 입력의 한 줄(개행 문자 기준)씩 읽어 반환하는 함수를 구현하는 과제

---
- 과정

1. c언어의 read 함수와 표준 입력, 파일 디스크립터의 활용에 대해 이해한다.
2. 특정 size의 buffer만큼 파일 혹은 입력을 읽고, 그 안에 개행문자가 있는지 확인한다.
3. 개행 문자가 없다면 읽었던 버퍼를 따로 저장해두고 개행 문자를 읽을 때까지 반복하여 읽는다.
4. 개행 문자를 읽었다면, 여태 읽은 문자들과 현재 읽은 것 중 개행 문자까지를 하나의 문자열로 연결하여 반환한다.
5. 개행 문자가 현재 읽은 문자열의 마지막 문자가 아니라면 개행 문자 이후의 문자들을 static 변수에 문자열 형태로 저장한다.
6. 함수 호출 시 static에 존재하는 문자열을 포함하여 위 과정을 반복한다.

---
- 어려웠던 점

1. 개행 문자를 읽지 못한다면 buffer size만큼 계속 반복해서 문자열을 읽어오는데, 이 문자열들을 관리하기 위해 linked-list를 사용했다. 해당 과정에는 어려움이 없었지만 42 seoul의 norminette라는 특수한 규정에 맞춰서 코드를 작성하느라, linked-list를 사용할 경우 코드의 분량이 크게 늘어 해당 코드를 압축하고 줄이는 과정이 필요했고 그로 인해 가독성이 안좋아지는 점에 고민을 많이했었다. 하지만 속도적 측면과 메모리의 관리적 측면에서 보면, reallocate를 구현하여 읽을 때마다 뒤에 붙이는 형태로 구현하는 것보다 linked-list를 통해 구현하는 것이 더 좋은 방법이라 생각이 들었다.
2. 여러 개의 파일 디스크립터에서 읽는 경우를 상정하여, static 변수를 여러 개를 사용하여야하는 부분이 있었다. 사실 이는 배열을 통해 구현한다면 간단하게 해결이 되는 부분이지만, 컴퓨터 환경마다 열 수 있는 최대 파일디스크립터의 개수가 다르고 특정 환경에서 c에서 선언할 수 있는 최대 배열의 개수보다 넘는 케이스가 있기 때문에 그렇게 구현하면 안된다는 일부 평가자들의 주장으로 인해 해당 부분 또한 linked-list로 구현하게 되었다. 이는 위의 1번 문제처럼 코드 분량의 증가로 이어지는데, 이로 인해 함수별로 25줄 + 최대 10개 함수만을 사용하여 구현 할 수 있도록 코드를 줄이는 부분이 가장 어려웠다.

---
- 배운 점

1. readline 함수가 내부적으로 어떻게 동작하는지 이해할 수 있었다.
2. static 변수에 대해 이해하고, 이를 활용하는 방안을 직접 구현해볼 수 있었다.
3. linked-list의 사용에 대해 더 익숙해질 수 있었다.
4. 표준 입력과 파일 디스크립터의 개념에 대해 공부할 수 있었다.
