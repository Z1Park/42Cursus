- 개요

c++의 vector, map, set과 같은 container를 직접 구현해보면서, container와 iterator의 구조 및 동작에 대해 공부하는 과제

---
- 과정

1. container에서 사용될 util 함수들(is_integral, equal, pair 등)을 먼저 구현한다.
2. util 함수들을 기반으로 컨테이너 내부에서 값들을 순회하는 iterator를 구현한다.
3. set과 map에서 사용될 tree를 구현한다.
4. iterator와 tree를 기반으로 container를 구현한다.

---
- 어려웠던 점

1. c++에서만 사용되는 container의 내부 구조에 대해 이해하고 그를 구현하는 과제이다 보니, 과제를 수행하기 위해 들이는 노력 대비 그 효용성이 떨어져 42 과제 중 가장 하기 싫었던 과제였던 것 같다.
2. 보너스 과제로 set을 구현할 때 사용되는 트리로 red-black tree를 사용하라는 사항이 있었는데, red-black tree는 이해했으나 노드의 삽입이나 삭제에 있어서 노드의 회전과 색 변화에 대해서 모든 분기를 다 알고 이해하는 것이 어려웠고 또 그를 상황에 맞춰 코드로 구현하는 것이 가장 어려웠다.
3. iterator나 is_integral, lexocial_compare 등 c++ 내부에서만 사용될 것 같은 것들을 구현할 때, 이걸 내가 이해하고 구현해보고 나서 나중에 다시 돌아볼만한 일이 있을까에 대한 생각이 과제 하는 내내 들어서 의욕을 많이 꺾어 놓았다.
4. 과제를 진행하는 도중에 해당 과제가 42 서울 교육과정에서 사라진다는 이야기를 듣게 되었는데, 그 시점이 과제를 60% 이상 진행한 시점이여서 다시 되돌리기에 늦은 시점이였다. 그 때문에 불평불만이 매우 많은채로 과제를 진행하게 되었는데, 해당 과제가 사라지고 대체되어 들어오는 과제의 수준과 난이도가 이 과제와 비교했을 때 현격히 낮았기 때문에 과제를 했던 것을 후회한 적은 처음이였던 것 같다.

---
- 배운 점

1. c++의 컨테이너 내부 구조와 iterator에 대해 이해할 수 있었고, 트리를 직접 구현해보면서 map과 set과 같은 dictionary들이 왜 시간복잡도에서 우위를 가지는지에 대해 이해할 수 있었다.
2. Red-Black Tree를 직접 구현해보면서, Balanced tree를 왜 사용하는지와 그 원리에 대해 이해할 수 있었다.
3. c++의 컨테이너 내부를 순회하는 iterator의 원리에 대해 이해할 수 있었다.
4. c++의 여러 컨테이너들을 더 잘 사용할 수 있게 되었다.
